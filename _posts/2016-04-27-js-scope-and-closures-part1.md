---
layout: post
title:  "js scope and closures"
date:   2016-04-27 16:00:52
categories: js
---

### 作用域嵌套

当一个块或函数嵌套在另一个块或函数中时， 就发生了作用域的嵌套。 因此， 在当前作用
域中无法找到某个变量时， 引擎就会在外层嵌套的作用域中继续查找， 直到找到该变量，
或抵达最外层的作用域（ 也就是全局作用域） 为止。

    function foo(a) {
        console.log( a + b );
    }
    var b = 2;
    foo( 2 ); // 4

考虑如下代码：

    function foo(a) {
        console.log( a + b );
        b = a;
    } 
    foo( 2 );

第一次对 b 进行 RHS 查询时是无法找到该变量的。 也就是说， 这是一个“ 未声明” 的变
量， 因为在任何相关的作用域中都无法找到它。
如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量， 引擎就会抛出 ReferenceError
异常。 值得注意的是， ReferenceError 是非常重要的异常类型。

相较之下， 当引擎执行 LHS 查询时， 如果在顶层（ 全局作用域） 中也无法找到目标变量，
全局作用域中就会创建一个具有该名称的变量， 并将其返还给引擎， 前提是程序运行在非
“ 严格模式” 下。

ES5 中引入了“ 严格模式”。 同正常模式， 或者说宽松 / 懒惰模式相比， 严格模式在行为上
有很多不同。 其中一个不同的行为是严格模式禁止自动或隐式地创建全局变量。 因此， 在
严格模式中 LHS 查询失败时， 并不会创建并返回一个全局变量， 引擎会抛出同 RHS 查询
失败时类似的 ReferenceError 异常。

### 函数作用域

函数作用域的含义是指， 属于这个函数的全部变量都可以在整个函数的范围内使用及复
用（ 事实上在嵌套的作用域中也可以使用）。 这种设计方案是非常有用的， 能充分利用
JavaScript 变量可以根据需要改变值类型的“ 动态” 特性